# API 参考

## `createRenderer([options])`

使用（可选的）[选项](#renderer-options)创建一个 [`Renderer`](#class-renderer) 实例。

``` js
const { createRenderer } = require('vue-server-renderer')
const renderer = createRenderer({ ... })
```

## `createBundleRenderer(bundle[, options])`

使用 server bundle 和（可选的）[选项](#renderer-options)创建一个 [`BundleRenderer`](#class-bundlerenderer) 实例。

``` js
const { createBundleRenderer } = require('vue-server-renderer')
const renderer = createBundleRenderer(serverBundle, { ... })
```

`serverBundle` 参数可以是以下之一：

- 绝对路径，用于生成 bundle 文件（`.js` 或 `.json`）。必须以 `/` 开头，作为文件路径处理。

- 由 webpack + `vue-server-renderer/server-plugin` 生成的 bundle 对象。

- JavaScript 代码字符串（不推荐）。

更多细节请查看 [Server Bundle 指引](./bundle-renderer.md) 和[构建配置](./build-config.md)。

## `Class: Renderer`

- #### `renderer.renderToString(vm[, context], callback)`

  将 Vue 示例渲染为字符串。上下文对象(context object)可选。回调函数是典型的 Node.js 风格回调，其中第一个参数是 error，第二个参数是渲染的字符串。

- #### `renderer.renderToStream(vm[, context])`

  将 Vue 示例渲染为 Node.js 流(stream)。上下文对象(context object)可选。更多细节请查看[流式渲染](./streaming.md)。

## `Class: BundleRenderer`

- #### `bundleRenderer.renderToString([context, ]callback)`

  将 bundle 渲染为字符串。上下文对象(context object)可选。回调是一个典型的Node.js样式回调，其中第一个参数是错误，第二个参数是呈现的字符串。

- #### `bundleRenderer.renderToStream([context])`

  将 bundle 渲染为 Node.js 流(stream). 上下文对象(context object)可选。更多细节请查看[流式渲染](./streaming.md)。

## Renderer 选项

- #### `template`

  为整个页面的 HTML 提供一个模板。此模板应包含注释 `<!--vue-ssr-outlet-->`，作为渲染应用程序内容的占位符。

  模板还支持使用渲染上下文(render context)进行基本插值：

  - 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation)；
  - 使用三花括号(triple-mustache)进行非 HTML 转义插值(non-HTML-escaped interpolation)。

  当在渲染上下文(render context)找到某些数据时，模板会自动注入合适的内容：

  - `context.head`：（字符串）任意 head 标记(markup)，将注入到页面头部。

  - `context.styles`：（字符串）任意内联 CSS，将注入到页面头部。注意，如果对组件 CSS 使用 `vue-loader` + `vue-style-loader`，此属性将自动填充。

  - `context.state`：（对象）初始 Vuex store 状态，将作为 `window.__INITIAL_STATE__` 内联到页面。内联的 JSON 将使用 [serialize-javascript](https://github.com/yahoo/serialize-javascript)  自动清理，以防止 XSS 攻击。

  此外，当提供 `clientManifest` 时，模板会自动注入以下内容：

  - 渲染所需的客户端 JavaScript 和 CSS 资源（使用异步 chunk 自动推断）；
  - 为要渲染页面提供最佳的 `<link rel="preload/prefetch">` 资源提示。

  您也可以通过将 `inject: false` 传递给 renderer，来禁用所有自动注入。

  具体查看：

  - [使用一个页面模板](./basic.md#using-a-page-template)
  - [手动资源注入(Manual Asset Injection)](./build-config.md#manual-asset-injection)

- #### `clientManifest`

  - 2.3.0+

  Provide a client build manifest object generated by `vue-server-renderer/client-plugin`. The client manifest provides the bundle renderer with the proper information for automatic asset injection into the HTML template. For more details, see [Generating clientManifest](./build-config.md#generating-clientmanifest).

- #### `inject`

  - 2.3.0+

  Controls whether to perform automatic injections when using `template`. Defaults to `true`.

  See also: [Manual Asset Injection](./build-config.md#manual-asset-injection).

- #### `shouldPreload`

  - 2.3.0+

  A function to control what files should have `<link rel="preload">` resource hints generated.

  By default, only JavaScript and CSS files will be preloaded, as they are absolutely needed for your application to boot.

  For other types of assets such as images or fonts, preloading too much may waste bandwidth and even hurt performance, so what to preload will be scenario-dependent. You can control precisely what to preload using the `shouldPreload` option:

  ``` js
  const renderer = createBundleRenderer(bundle, {
    template,
    clientManifest,
    shouldPreload: (file, type) => {
      // type is inferred based on the file extension.
      // https://fetch.spec.whatwg.org/#concept-request-destination
      if (type === 'script' || type === 'style') {
        return true
      }
      if (type === 'font') {
        // only preload woff2 fonts
        return /\.woff2$/.test(file)
      }
      if (type === 'image') {
        // only preload important images
        return file === 'hero.jpg'
      }
    }
  })
  ```

- #### `runInNewContext`

  - 2.3.0+
  - only used in `createBundleRenderer`
  - Expects: `boolean | 'once'` (`'once'` only supported in 2.3.1+)

  By default, for each render the bundle renderer will create a fresh V8 context and re-execute the entire bundle. This has some benefits - for example, the app code is isolated from the server process and we don't need to worry about the [stateful singleton problem](./structure.md#avoid-stateful-singletons) mentioned in the docs. However, this mode comes at some considerable performance cost because re-executing the bundle is expensive especially when the app gets bigger.

  This option defaults to `true` for backwards compatibility, but it is recommended to use `runInNewContext: false` or `runInNewContext: 'once'` whenever you can.

  > In 2.3.0 this option has a bug where `runInNewContext: false` still executes the bundle using a separate global context. The following information assumes version 2.3.1+.

  With `runInNewContext: false`, the bundle code will run in the same `global` context with the server process, so be careful about code that modifies `global` in your application code.

  With `runInNewContext: 'once'` (2.3.1+), the bundle is evaluated in a separate `global` context, however only once at startup. This provides better app code isolation since it prevents the bundle from accidentally polluting the server process' `global` object. The caveats are that:

  1. Dependencies that modifies `global` (e.g. polyfills) cannot be externalized in this mode;
  2. Values returned from the bundle execution will be using different global constructors, e.g. an error caught inside the bundle will not be an instance of `Error` in the server process.

  See also: [Source Code Structure](./structure.md)

- #### `basedir`

  - 2.2.0+
  - only used in `createBundleRenderer`

  Explicitly declare the base directory for the server bundle to resolve `node_modules` dependencies from. This is only needed if your generated bundle file is placed in a different location from where the externalized NPM dependencies are installed, or your `vue-server-renderer` is npm-linked into your current project.

- #### `cache`

  Provide a [component cache](./caching.md#component-level-caching) implementation. The cache object must implement the following interface (using Flow notations):

  ``` js
  type RenderCache = {
    get: (key: string, cb?: Function) => string | void;
    set: (key: string, val: string) => void;
    has?: (key: string, cb?: Function) => boolean | void;
  };
  ```

  A typical usage is passing in an [lru-cache](https://github.com/isaacs/node-lru-cache):

  ``` js
  const LRU = require('lru-cache')

  const renderer = createRenderer({
    cache: LRU({
      max: 10000
    })
  })
  ```

  Note that the cache object should at least implement `get` and `set`. In addition, `get` and `has` can be optionally async if they accept a second argument as callback. This allows the cache to make use of async APIs, e.g. a redis client:

  ``` js
  const renderer = createRenderer({
    cache: {
      get: (key, cb) => {
        redisClient.get(key, (err, res) => {
          // handle error if any
          cb(res)
        })
      },
      set: (key, val) => {
        redisClient.set(key, val)
      }
    }
  })
  ```

- #### `directives`

  Allows you to provide server-side implementations for your custom directives:

  ``` js
  const renderer = createRenderer({
    directives: {
      example (vnode, directiveMeta) {
        // transform vnode based on directive binding metadata
      }
    }
  })
  ```

  As an example, check out [`v-show`'s server-side implementation](https://github.com/vuejs/vue/blob/dev/src/platforms/web/server/directives/show.js).

## Webpack Plugins

The webpack plugins are provided as standalone files and should be required directly:

``` js
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')
const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')
```

The default files generated are:

- `vue-ssr-server-bundle.json` for the server plugin;
- `vue-ssr-client-manifest.json` for the client plugin.

The filenames can be customized when creating the plugin instances:

``` js
const plugin = new VueSSRServerPlugin({
  filename: 'my-server-bundle.json'
})
```

See [Build Configuration](./build-config.md) for more information.

***

> 原文：https://ssr.vuejs.org/en/api.html