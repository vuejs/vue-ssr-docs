# 유니버셜 코드 작성하기

SSR에 대해 더 살펴보기 전에 잠시 "유니버설" 코드, 즉 서버와 클라이언트 모두에서 실행 가능한 코드를 작성하는 경우의 제약사항에 관하여 살펴봅니다. 유즈 케이스 및 플랫폼 API의 차이로 인해 다른 환경에서 실행할 때 코드의 동작이 정확히 동일할 수는 없습니다. 여기서는 서버 렌더링을 함에 있어서 알아야 할 중요한 항목에 대해 설명합니다.

## 서버에서의 데이터 반응성

클라이언트에서만 실행되는 앱에서는 모든 사용자가 브라우저에서 앱의 새 인스턴스를 사용하게 됩니다. 서버 측 렌더링의 경우에도 동일한 요청이 필요합니다. 각 요청에는 교차 요청 상태(Cross Request State) 오염이 없도록 격리된 새 앱 인스턴스가 있어야 합니다.

실제 렌더링 프로세스는 결정적이어야 하므로 서버에서 데이터를 "프리 페치(pre-fetching)"를 할 수도 있습니다. 렌더링을 시작할 때 애플리케이션 상태는 이미 완료되어 있어야 합니다. 즉, 서버에서 데이터 반응성이 필요하지 않으므로 기본적으로 비활성화되어 있습니다. 데이터 반응성을 비활성화하면 데이터를 반응형 객체로 변환하는 성능 비용을 피할 수 있습니다.

## 컴포넌트 라이프사이클 훅

동적 업데이트가 없기때문에 라이프사이클 Hook 중 `beforeCreate` 및 `created`만 SSR 중에 호출됩니다. 즉, `beforeMount` 또는 `mounted`와 같은 다른 라이프사이클 Hook 코드는 클라이언트에서만 실행됩니다.

또 다른 주의해야 할점은 `beforeCreate`와 `created`에서, 예를 들면 `setIterval` 타이머를 설정하는 등 전역부작용을 일으킬 코드는 피해야합니다. 클라이언트측 코드만으로 타이머를 설정한 다음 `beforeDestory` 또는 `destroyed`로 분리할 수 있습니다. 그러나 SSR 중 destroy Hook 가 호출되지 않기 때문에 타이머가 영원히 유지됩니다. 이를 피하려면 사이드이펙트를 발생하는 코드를 `beforeMount` 또는 `mounted` 로 옮겨야 합니다.

## 플랫폼에 의존하는 API에 접근하기

유니버설 코드는 특정 플랫폼의 고유의 API에 액세스 하도록 설계되어 있지 않기 때문에, `window` 또는 `document`와 같은 브라우저 환경 전역 변수를 직접 사용하면 Node.js에서 오류가 발생합니다.

서버와 클라이언트 간 코드는 공유되지만, 작업에 사용되는 API가 플랫폼에 따라 달라지는 경우 플랫폼 별 구현을 범용적인 API로 래핑 하거나 이를 위해 라이브러리를 사용하는 것이 좋습니다. 예를 들어 [axios](https://github.com/mzabriskie/axios)는 서버와 클라이언트 모두에서 동일한 API를 제공하는 HTTP 클라이언트입니다.

브라우저 API를 사용하기 위한 일반적인 방법은 클라이언트 실행되는 라이프사이클에서 지연 접근(Lazyily Access)을 하는 것입니다.

써드파티 라이브러리가 범용으로 사용하는 것을 고려하지 않고 작성된 경우, 서버에서 렌더링 된 애플리케이션과 통합하는 것이 까다로울 수 있기 때문에 주의해야 합니다. 일부 전역 변수를 가짜로 만들어(mocking) *작동시킬 수 있으나* 이는 편법이며 다른 라이브러리의 환경설정 감지 코드를 건드릴 수 있습니다.

## 사용자 정의 디렉티브

대부분의 사용자 정의 디렉티브는 DOM을 직접 조작하므로 SSR중 오류가 발생합니다. 이 문제를 해결하는 방법은 두가지 입니다.

1. 추상화 메커니즘으로 컴포넌트를 사용하고 가상 DOM 수준에서 작업해야합니다. (예 : 렌더링 기능 사용)
2. 컴포넌트로 쉽게 바꿀 수 없는 사용자 정의 디렉티브가 있는 경우 서버 렌더러를 생성할 때 [`directives`](./api.md#directives)옵션을 사용해 "서버 사이드 버전"을 준비하여 해결할 수 있습니다.
