# Маршрутизация и разделение кода

## Маршрутизация с помощью `vue-router`

Возможно вы заметили, что в нашем серверном коде используется обработчик для `*`, который принимает любые URL-адреса. Это позволяет нам передавать посещённый URL в наше приложение Vue, и использовать одну конфигурацию маршрутизации как для клиента, так и для сервера!

Для этой цели рекомендуется использовать официальный `vue-router`. Давайте сначала создадим файл, в котором мы будем создавать маршрутизатор. Обратите внимание, что как и для `createApp`, нам потребуется новый экземпляр маршрутизатора для каждого запроса, поэтому файл экспортирует функцию `createRouter`:

``` js
// router.js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

export function createRouter () {
  return new Router({
    mode: 'history',
    routes: [
      // ...
    ]
  })
}
```

И обновим `app.js`:

``` js
// app.js
import Vue from 'vue'
import App from './App.vue'
import { createRouter } from './router'

export function createApp () {
  // Создаём экземпляр маршрутизатора
  const router = createRouter()

  const app = new Vue({
    // внедряем маршрутизатор в корневой экземпляр Vue
    router,
    render: h => h(App)
  })

  // возвращаем и приложение и маршрутизатор
  return { app, router }
}
```

Теперь нам нужно реализовать логику маршрутизации на стороне сервера в `entry-server.js`:

``` js
// entry-server.js
import { createApp } from './app'

export default context => {
  // поскольку могут быть асинхронные хуки маршрута или компоненты,
  // мы будем возвращать Promise, чтобы сервер смог дожидаться
  // пока всё не будет готово к рендерингу.
  return new Promise((resolve, reject) => {
    const { app, router } = createApp()

    // устанавливаем маршрут для маршрутизатора серверной части
    router.push(context.url)

    // ожидаем, пока маршрутизатор разрешит возможные асинхронные компоненты и хуки
    router.onReady(() => {
      const matchedComponents = router.getMatchedComponents()
      // нет подходящих маршрутов, отклоняем с 404
      if (!matchedComponents.length) {
        return reject({ code: 404 })
      }

      // Promise должен разрешиться экземпляром приложения, который будет отрендерен
      resolve(app)
    }, reject)
  })
}
```

Предполагая, что серверная сборка уже есть (опять же, опуская сейчас установку сборки), использование сервера будет выглядеть так:

``` js
// server.js
const createApp = require('/path/to/built-server-bundle.js')

server.get('*', (req, res) => {
  const context = { url: req.url }

  createApp(context).then(app => {
    renderer.renderToString(app, (err, html) => {
      if (err) {
        if (err.code === 404) {
          res.status(404).end('Страница не найдена')
        } else {
          res.status(500).end('Внутренняя ошибка сервера')
        }
      } else {
        res.end(html)
      }
    })
  })
})
```

## Разделение кода

Разделение кода (code-splitting), или ленивая загрузка вашего приложения, помогает уменьшить количество ресурсов, которые необходимо загрузить браузеру для первоначального рендеринга, и может значительно улучшить TTI (time-to-interactive — время до интерактивности) для приложений с большими сборками. Ключ к этому — «загружать только то, что нужно» для начального экрана.

Vue предоставляет асинхронные компоненты в качестве первоклассной концепции, в сочетании с [поддержкой Webpack 2 для использования динамических импортов в качестве точек разделения кода](https://webpack.js.org/guides/code-splitting-async/). Всё что вам нужно сделать это:

``` js
// изменить это...
import Foo from './Foo.vue'

// на это:
const Foo = () => import('./Foo.vue')
```

Это будет работать в любом сценарии, если вы создаёте чисто клиентское приложение Vue. Однако есть некоторые ограничения при использовании серверного рендеринга. Во-первых, вам нужно разрешить все асинхронные компоненты на сервере перед началом рендеринга, потому что иначе вы просто получите пустое место в разметке. На клиенте вам также нужно сделать это перед началом гидратации, иначе клиент столкнётся с ошибками несоответствующего содержимого.

Это делает использование асинхронных компонентов в произвольных местах вашего приложения непростой задачей (в скором времени мы планируем исправить эту ситуацию). Однако, **это будет работать без сбоев, если вы делаете это на уровне маршрутов** — т.е. используете асинхронные компоненты в конфигурации ваших маршрутов — потому что `vue-router` автоматически будет разрешать требуемые асинхронные компоненты при разрешении маршрута. Что вам нужно сделать, это убедиться что используете `router.onReady` и на сервере и на клиенте. Мы уже сделали это в серверной точке входа, и теперь нам нужно обновить клиентскую точку входа:

``` js
// entry-client.js

import { createApp } from './app'

const { app, router } = createApp()

router.onReady(() => {
  app.$mount('#app')
})
```

Пример конфигурации маршрута с асинхронными компонентами:

``` js
// router.js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

export function createRouter () {
  return new Router({
    mode: 'history',
    routes: [
      { path: '/', component: () => import('./components/Home.vue') },
      { path: '/item/:id', component: () => import('./components/Item.vue') }
    ]
  })
}
```
