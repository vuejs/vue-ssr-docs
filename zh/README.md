# Vue.js 服务端渲染指南

> **注意:** 本指南需要以下版本的Vue和支持库:
> - vue & vue-server-renderer >= 2.3.0
> - vue-router >= 2.5.0
> - vue-loader >= 12.0.0 & vue-style-loader >= 3.0.0

> 如果你之前已经使用过 Vue2.2 和 SSR, 你会发现推荐的代码结构与现在的[有所不同](./structure.md) (新版本 [runInNewContext](./api.md#runinnewcontext) 选项设置为 `false`). 您现有的应用程序应该是可以继续工作的, 但建议您迁移到新的建议.

## 什么是服务端渲染 (SSR)?

Vue.js是构建客户端应用程序的框架. 默认情况下, Vue组件在浏览器中生成和操作DOM作为输出. 然而,我们也可以在服务器将同样的组件渲染成HTML字符串, 然后直接发送给浏览器, 最终将静态标记"水合"为在客户端完全交互的app.

服务器渲染的Vue.js应用程序也可以被认为是“同构”或“通用”, 因为您的应用程序的大部分代码在服务器和客户端上运行.

## 为什么用SSR?

与传统SPA（单页应用）相比, SSR的优势主要在于:

- 更好的搜索引擎优化, 搜索引擎抓取工具将直接看到完全呈现的页面.

  请注意, 截至目前, Google和Bing可以对同步JavaScript应用程序很好得索引. 同步是个关键词! 如果您的应用程序以一个 loading spanner 开始, 然后通过Ajax获取内容，爬虫程序不会等待您去完成. 这意味着如果您在SEO重要的页面上异步获取内容, 则可能需要SSR.

- 更快的time-to-content, 特别是在缓慢的互联网或缓慢的设备. 服务器渲染的标记不需要等待所有的JavaScript都被下载并执行显示, 所以你的用户将会更快地看到一个完全呈现的页面. 这通常导致更好的用户体验, 并且对于time-to-content与转换率直接相关的应用程序可能是至关重要的.

使用SSR时也需要考虑一些权衡：

- 开发上的限制. 浏览器特定的代码只能在某些生命周期钩子中使用; 一些外部库可能需要特殊处理才能在服务器渲染的应用程序中运行.

- 涉及更多构建设置和部署要求. 与可以部署在任何静态文件服务器上的完全静态SPA不同, 服务器渲染的app需要可以在Node.js服务器运行的环境.

- 更高的服务器端负载. 在Node.js中呈现完整的应用程序显然会比仅提供静态文件更加CPU密集, 因此如果您期望高流量, 请准备相应的服务器负载并明智地采用缓存策略.

在您的应用程序使用SSR之前, 您应该问第一个问题是否真的需要它. 这主要取决于您的应用程序对于time-to-content的重要性. 例如, 如果您正在构建一个内部仪表板, 初始加载的额外的几百毫秒并不重要, SSR将完全没必要. 然而, 在时间到内容绝对关键的情况下, SSR可以帮助您实现最佳的初始负载性能.

## SSR vs 预渲染

如果你研究SSR只是为了改善少数营销页面的SEO (e.g. `/`, `/about`, `/contact`, etc), 那么你可能需要__prerendering__代替. 预渲染仅仅在构建的时候为特定的路由生成静态HTML文件, 而不是使用Web服务器即时编译HTML. 优点是使用prerendering更简单，并允许您将您的前端作为一个完全静态的站点。.

如果你使用webpack, 你可以很容易地使用[prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)添加预渲染.  它已经被Vue应用程序广泛测试 - 事实上, [创建者](https://github.com/chrisvfritz) 是Vue项目核心团队的成员.

## 关于本指南

本指南专注于使用Node.js作为服务器的服务端渲染的单页面应用程序. 将Vue SSR与其他后端设置进行混合是其自身的一个主题, 本指南中未涉及.

本指南将非常深入, 并且假设您已经熟悉Vue.js本身, 并且具有Node.js和webpack的基础知识. 如果你更喜欢一种更高级的, 能提供流畅的开箱即用体验的解决方案, 您应该尝试[Nuxt.js](http://nuxtjs.org/). 它建立在相同的Vue堆栈上, 但抽象出很多样板, 并提供了一些额外的功能, 如静态站点生成. 但是, 如果你需要更直接地控制应用程序的结构, 就可能不适合用于你的使用场景. 无论如何, 阅读本指南将更有助于更好地了解事情如何协同工作.

当您阅读时, 参考官方[HackerNews Demo](https://github.com/vuejs/vue-hackernews-2.0/)将有所帮助, 这些使用了本指南涵盖的大部分技术。

最后, 请注意, 本指南中的解决方案不是固定的 - 我们发现它们对我们来说很好, 但这并不意味着它们不能被改进. 他们可能会在未来修改, 并通过提交拉动请求自由作出贡献!